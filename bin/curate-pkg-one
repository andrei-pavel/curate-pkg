#!/bin/bash

# Copyright (C) 2017-2018 Andrei Pavel, andrei.pavel@cti.pub.ro
# Licensed under the MIT License

# Get script path and append it to PATH so other scripts are callable.
SCRIPT_PATH="$(dirname "$(readlink -f "${0}")")"
PATH="${PATH}:${SCRIPT_PATH}"

# Header
ARGUMENTS="\
  [-i|--install \$package]            Installs a single package.
  [-k|--add-key \$key]                Adds a single key.
  [-p|--purge|--remove \$package]     Removes a single package.
  [-r|--add-repository \$repository]  Adds a single repository.
  [-s|--add-source \$source]          Adds a single source.
  [-u|--upgrade \$package]            Upgrades a single package.
  [-v|--verbose]                     Verbose output
  \$package_manager                   Run only for this specific package manager.
"
. "${SCRIPT_PATH}/../share/curate-pkg/header"
. "${SCRIPT_PATH}/../share/curate-pkg/spinner"

# Parse arguments.
package_manager=
verbose="&> /dev/null"
add_key_item=
add_repository_item=
add_source_item=
install_item=
purge_item=
upgrade_item=
explicit=false
while (( ${#} > 0 )); do
  case "${1}" in
  # [-i|--install \$package]            Installs a single package.
  '-i');& '--install') shift && install_item="${1}" && explicit=true;;
  # [-k|--add-key \$key]                Adds a single key.
  '-k');& '--add-key') shift && add_key_item="${1}" && explicit=true;;
  # [-p|--purge|--remove \$package]     Removes a single package.
  '-p');& '--purge');& '--remove') shift && purge_item="${1}" && explicit=true;;
  # [-r|--add-repository \$repository]  Adds a single repository.
  '-r');& '--add-repository') shift && add_repository_item="${1}" && explicit=true;;
  # [-s|--add-source \$source]          Adds a single source.
  '-s');& '--add-source') shift && add_source_item="${1}" && explicit=true;;
  # [-u|--upgrade \$package]            Upgrades a single package.
  '-u');& '--upgrade') shift && upgrade_item="${1}" && explicit=true;;
  # [-v|--verbose]                     Verbose output
  '-v');& '--verbose') shift && verbose='' && explicit=true;;
  *)
    # \$package_manager                   Run only for this specific package manager.
    [[ -z "${package_manager}" ]] && package_manager="${1}" && shift && continue
    # Unrecognized argument
    printf "${RED}ERROR: Unrecognized argument '%s'${RESET}\\n" "${1}" 1>&2; printUsage; exit 1;;
  esac; shift
done

#------------------------------------------------------------------------------#

function cleanup() {
  ${cleanup_added_sources}
  spinner_end 0 &> /dev/null
}

function printHeader() {
  local title="${1}"
  local column_count="$(tput cols)"
  local hash_count=$((column_count - 2 - ${#title}))
  local one_side_column_count="$((hash_count / 2))"
  for (( i=0; i < "${one_side_column_count}"; i++ )); do
    printf "#"
  done
  printf " %s " "${title}"
  if [[ $((hash_count % 2)) -eq 1 ]]; then
    one_side_column_count=$((one_side_column_count + 1))
  fi
  for (( i=0; i < "${one_side_column_count}"; i++ )); do
    printf "#"
  done
  printf "\n"
}

function spinner_begin() {
  local message="${1}"
  if [[ "${-}" != *x* ]]; then
    start_spinner "${message}"
  fi
}

function spinner_end() {
  if [[ "${-}" != *x* ]]; then
    stop_spinner 0
  fi
}

function install_function() {
  local package="${1}"
  eval "install_ \"${package}\" ${verbose}" || true
  installed_packages+=("${package}")
}

function add_key_function() {
  local key="${1}"
  eval "wget -q -O - \"${key}\" | add_key_ - ${verbose}"
  added_keys+=("${key}")
}

function purge_function() {
  local package="${1}"
  eval "purge_ \"${package}\" ${verbose}"
  purged_packages+=("${package}")
}

function add_repository_function() {
  local repository="${1}"
  eval "add_repository_ \"${repository}\" ${verbose}" || true
  added_repositories+=("${repository}")
}

function add_source_function() {
  local source="${1}"
  eval "add_source_ \"${source}\" ${verbose}"
  added_sources+=("${source}")
}

function upgrade_function() {
  local package="${1}"
  eval "upgrade_ ${package} ${verbose}"
  upgraded_packages+=("${package}")
}

printHeader ${package_manager}
source "${SCRIPT_PATH}/../share/curate-pkg/package-managers/${package_manager}.sh"
if ! command -v yq 1> /dev/null; then
  ${install} yq
fi

if ! ${explicit}; then
  # Find out what there is to be done.
  keys=("$(yq -r '.["keys"][]?' < "${config}")")
  repositories=("$(yq -r '.["repositories"][]?' < "${config}")")
  sources=()
  for (( i=0; ; i++ )); do
    src="$(yq -r '.["sources"]'[${i}] < "${config}")"
    if [[ ${src} == null ]]; then
      break
    fi
      sources+=( "${src}" )
  done
  installables=("$(yq -r '.["installables"][]?' < "${config}")")
  wgetables=("$(yq -r '.["wgetables"][]?' < "${config}")")
  purgeables=("$(yq -r '.["purgeables"][]?' < "${config}")")
  commands=()
  for (( i=0; ; i++ )); do
    cmd="$(yq -r '.["commands"]'[${i}] < "${config}")"
    if [[ ${cmd} == null ]]; then
      break
    fi
      commands+=( "${cmd}" )
  done
fi

added_keys=()
added_repositories=()
added_sources=()
upgraded_packages=()
installed_packages=()
wgot_packages=()
purged_packages=()

# Do.
spinner_begin "Adding keys..."
if ${explicit}; then
  if [[ ! -z ${add_key_item} ]]; then
    add_key_function "${add_key_item}"
  fi
else
  for key in ${keys[@]}; do
    add_key_function "${key}"
  done
fi
spinner_end
(( ${#added_keys[@]} > 0 )) && printf "${GREEN}Added keys: %s${RESET}\n" "${added_keys[@]}"

spinner_begin "Adding repositories..."
if ! ${explicit}; then
  if [[ ! -z ${add_repository_item} ]]; then
    add_repository_function "${add_repository_item}"
  fi
else
  for repository in ${repositories[@]}; do
    add_repository_function "${repository}"
  done
fi
spinner_end
(( ${#added_repositories[@]} > 0 )) && printf "${GREEN}Added repositories: %s${RESET}\n" "${added_repositories[@]}"

spinner_begin "Adding sources..."
eval "cleanup_added_sources_ ${verbose}"
if ${explicit}; then
  if [[ ! -z ${add_source_item} ]]; then
    add_source_function "${add_source_item}"
  fi
else
  for src in "${sources[@]}"; do
    protocolless_src=$(echo "${src}" | cut -d '/' -f 3-)
    if [[ ! -z ${source_files} ]]; then
      if ! /bin/grep -F "$(echo "${protocolless_src}")" ${source_files} &> /dev/null; then
        add_source_function "${source}"
      fi
    fi
  done
fi
spinner_end
(( ${#added_sources[@]} > 0 )) && printf "${GREEN}Added sources: %s${RESET}\n" "${added_sources[@]}"

spinner_begin "Updating repositories..."
eval "update_ ${verbose}" || true
spinner_end
(( ${#updated_repositories[@]} > 0 )) && printf "${GREEN}Updated repositories: %s${RESET}\n" "${updated_repositories[@]}"

spinner_begin "Installing..."
if ${explicit}; then
  if [[ ! -z ${install_item} ]]; then
    install_function ${install_item}
  fi
else
  for package in ${installables[@]}; do
    set +e
    eval "check_package_ \"${package}\"" ${verbose}
    return_code=${?}
    set -e
    if [[ ${return_code} -ne 0 ]]; then
      install_function "${package}"
    fi
  done
fi
spinner_end
(( ${#installed_packages[@]} > 0 )) && printf "${GREEN}Installed packages: %s${RESET}\n" "${installed_packages[@]}"

if ! ${explicit}; then
  spinner_begin "wgetting..."
  for wget in ${wgetables[@]}; do
    name=$(echo ${wget} | cut -d '/' -f 3 | cut -d '.' -f 2)
    directory="/usr/local/${name}"
    if [[ ! -d ${directory} ]]; then
      mkdir --parents ${directory}
      file=$(mktemp --dry-run --tmpdir=${directory})
      wget -q -O "${file}" "${wget}"
      filetype=$(file "${file}")
      if echo ${filetype} | /bin/grep -Ec "gzip|Zip" &> /dev/null; then
          pushd ${directory}
          {
            eval "unp \"${file}\" ${verbose}"
          }
          popd
      else
        eval "manual_install_ \"${file}\" ${verbose}"
      fi
      rm "${file}"
    fi
    wgot_packages+=("${wget}")
  done
  spinner_end
fi
(( ${#wgot_packages[@]} > 0 )) && printf "${GREEN}wgot packages: %s${RESET}\n" "${wgot_packages[@]}"

spinner_begin "Purging..."
if ${explicit}; then
  if [[ ! -z ${purge_item} ]]; then
    purge_function "${purge_item}"
  fi
else
  for package in ${purgeables[@]}; do
    set +e
    eval "check_package_ \"${package}\" ${verbose}"
    return_code=${?}
    set -e
    if [[ ${return_code} -eq 0 ]]; then
      purge_function "${package}"
    fi
  done
fi
spinner_end
(( ${#purged_packages[@]} > 0 )) && printf "${GREEN}Purged packages: %s${RESET}\n" "${purged_packages[@]}"

spinner_begin "Upgrading..."
if ${explicit}; then
  if [[ ! -z ${upgrade_item} ]]; then
    upgrade_function ${upgrade_item}
  fi
else
  upgrade_function
fi
spinner_end

if ! ${explicit}; then
spinner_begin "Running custom commands..."
for cmd in "${commands[@]}"; do
    eval "${cmd} ${verbose}"
  done
spinner_end
fi

spinner_begin "Removing unused packages..."
eval "autoremove_ ${verbose}"
spinner_end

spinner_begin "Upgrading operating system..."
eval "upgrade_os_ ${verbose}" || true
spinner_end

eval "cleanup_added_sources_ ${verbose}"
